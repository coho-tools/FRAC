//***************************************
// user code copied to the file here.
//***************************************

package coho.interp;	//define the package
import java_cup.runtime.*;  	//import cup
import java.io.*;

//Usually, the default class name is Yylex, the default function name is yylex and the default return type is Yytoken
//We can change the default value by %class <name> %funciton <name> and %type<name> in the second part sepearately.
//1) We usually add user code for the definiation of return class. Here, we use Symbol from CUP.
//2) And also we define constants that corresponding to each token type. We use the definiation of Sym.java generated by cup.
//   And also we have a map provided by SymboleName.java.


//***************************************
// JLex Directives.
//***************************************
%%
%cup				//CUP compatibility. or use: %implements java_cup.runtime.Scanner %function next_token %type java_cup.runtime.Symbol
%class Scanner
%line				//turn on line counting
%char				//turn on char counting
%public				//we need make this class public?
%yyeof				//decare the YYEOF constant //%state we don't need new state here

%{				//user code copied to the class
	// map the string name to Symbol.
	private PTfactory pf;
	private SymbolName sname;
	private Symbol symbol(String name) {
	    int key = sname.nameToKey(name);
	    return(new Symbol(key, pf.create(key, yytext())));
	}
	// Constructor to initilize pf and sname.
	public Scanner(java.io.Reader reader, PTfactory _pf, SymbolName _sname) {
    	    this(reader);
    	    pf = _pf;
    	    sname = _sname;
  	}
  	// test file
  	public static void main(String args[]) throws Exception {
    	    PTfactory pf = new PTnodeFactory();
    	    SymbolName sname = new SymbolName();
    	    Scanner s = new Scanner(new InputStreamReader(System.in), pf, sname);
    	    PTnode pt;
    	    int endKey = sname.nameToKey("EOF");
    	    System.out.println("Scanner.main: start typing tokens");
	    do {
	      pt = (PTnode)(s.next_token().value);
	      System.out.print(pt+"\n");
	    } while(pt.key() != endKey);
     	}
%}
%eofval{			//return the special symbol at the end of file. Maybe executed more than once.
	return(symbol("EOF"));
%eofval}



WHITE_SPACE=([\ \n\r\t\f])+			
COMMENT="%"[^\n]*
ALPHA=[a-zA-Z_]	
DIGIT=[0-9]
ALPHA_NUMERIC={ALPHA}|{DIGIT}
IDENT={ALPHA}({ALPHA_NUMERIC})*
NUMBER={DIGIT}+
SIGN_NUMBER=([+-])?{NUMBER}
EXPONENT=[eE]{SIGN_NUMBER}
HEX_DIGIT=[0-9a-f]
HEX_NUMBER=[+-]?({HEX_DIGIT})+


%%
<YYINITIAL> "," { return symbol("COMMA"); }
<YYINITIAL> ";" { return symbol("SEMI"); }
<YYINITIAL> "(" { return symbol("LPAREN"); }
<YYINITIAL> ")" { return symbol("RPAREN"); }
<YYINITIAL> "[" { return symbol("LBRACKET"); }
<YYINITIAL> "]" { return symbol("RBRACKET"); }
<YYINITIAL> "-" { return symbol("MINUS"); }
<YYINITIAL> "=" { return symbol("ASSIGN"); }

<YYINITIAL> {COMMENT} {}		
<YYINITIAL> {WHITE_SPACE} {}		
<YYINITIAL> {IDENT} { return symbol("IDENT");}	
<YYINITIAL> "'"([^']|(''))*"'" { return symbol("STRING");}	
<YYINITIAL> (({SIGN_NUMBER}("."{NUMBER})?)|(([+-])?"."{NUMBER}))({EXPONENT})?  {return symbol("PLAIN_DOUBLE");}
<YYINITIAL> ("$"{HEX_NUMBER}) {  return symbol("HEX_DOUBLE");}

<YYINITIAL> . { return symbol("LEX_ERROR"); }
